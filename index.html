<!DOCTYPE html>
<html>
	<head>
		<title>Procedural Solar System</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: tahoma;
				font-size:13px;
				background-color: black;
				margin: 0px;
				overflow: hidden;
				box-sizing: border-box; 
				margin: 0; 
				padding: 0;
			}
		</style>
	</head>
	<body>
		<div id="container">
		</div>

		<!------------- ADDING NECCESARY SCRIPTS ------------->
		<script src="js/three.min.js"></script>
		<script src="js/dat.gui.min.js"></script>

		<!--------- VERTEX SHADER - FOR EDITABLE SUN --------->
		<script type="x-shader/x-vertex" id="vertexShader">
			
			// ---------------------------- NOISE --------------------------->
				//
				// GLSL textureless classic 3D noise "cnoise",
				// with an RSL-style periodic variant "pnoise".
				// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
				// Version: 2011-10-11
				//
				// Many thanks to Ian McEwan of Ashima Arts for the
				// ideas for permutation and gradient selection.
				//
				// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
				// Distributed under the MIT license. See LICENSE file.
				// https://github.com/stegu/webgl-noise
				//

				vec3 mod289(vec3 x)
				{
				  return x - floor(x * (1.0 / 289.0)) * 289.0;
				}

				vec4 mod289(vec4 x)
				{
				  return x - floor(x * (1.0 / 289.0)) * 289.0;
				}

				vec4 permute(vec4 x)
				{
				  return mod289(((x*34.0)+1.0)*x);
				}

				vec4 taylorInvSqrt(vec4 r)
				{
				  return 1.79284291400159 - 0.85373472095314 * r;
				}

				vec3 fade(vec3 t) {
				  return t*t*t*(t*(t*6.0-15.0)+10.0);
				}

				// Classic Perlin noise
				float cnoise(vec3 P)
				{
				  vec3 Pi0 = floor(P); // Integer part for indexing
				  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
				  Pi0 = mod289(Pi0);
				  Pi1 = mod289(Pi1);
				  vec3 Pf0 = fract(P); // Fractional part for interpolation
				  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
				  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
				  vec4 iy = vec4(Pi0.yy, Pi1.yy);
				  vec4 iz0 = Pi0.zzzz;
				  vec4 iz1 = Pi1.zzzz;

				  vec4 ixy = permute(permute(ix) + iy);
				  vec4 ixy0 = permute(ixy + iz0);
				  vec4 ixy1 = permute(ixy + iz1);

				  vec4 gx0 = ixy0 * (1.0 / 7.0);
				  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
				  gx0 = fract(gx0);
				  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
				  vec4 sz0 = step(gz0, vec4(0.0));
				  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
				  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

				  vec4 gx1 = ixy1 * (1.0 / 7.0);
				  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
				  gx1 = fract(gx1);
				  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
				  vec4 sz1 = step(gz1, vec4(0.0));
				  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
				  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

				  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
				  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
				  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
				  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
				  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
				  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
				  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
				  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

				  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
				  g000 *= norm0.x;
				  g010 *= norm0.y;
				  g100 *= norm0.z;
				  g110 *= norm0.w;
				  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
				  g001 *= norm1.x;
				  g011 *= norm1.y;
				  g101 *= norm1.z;
				  g111 *= norm1.w;

				  float n000 = dot(g000, Pf0);
				  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
				  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
				  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
				  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
				  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
				  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
				  float n111 = dot(g111, Pf1);

				  vec3 fade_xyz = fade(Pf0);
				  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
				  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
				  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
				  return 2.2 * n_xyz;
				}

				// Classic Perlin noise, periodic variant
				float pnoise(vec3 P, vec3 rep)
				{
				  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
				  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
				  Pi0 = mod289(Pi0);
				  Pi1 = mod289(Pi1);
				  vec3 Pf0 = fract(P); // Fractional part for interpolation
				  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
				  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
				  vec4 iy = vec4(Pi0.yy, Pi1.yy);
				  vec4 iz0 = Pi0.zzzz;
				  vec4 iz1 = Pi1.zzzz;

				  vec4 ixy = permute(permute(ix) + iy);
				  vec4 ixy0 = permute(ixy + iz0);
				  vec4 ixy1 = permute(ixy + iz1);

				  vec4 gx0 = ixy0 * (1.0 / 7.0);
				  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
				  gx0 = fract(gx0);
				  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
				  vec4 sz0 = step(gz0, vec4(0.0));
				  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
				  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

				  vec4 gx1 = ixy1 * (1.0 / 7.0);
				  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
				  gx1 = fract(gx1);
				  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
				  vec4 sz1 = step(gz1, vec4(0.0));
				  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
				  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

				  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
				  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
				  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
				  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
				  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
				  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
				  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
				  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

				  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
				  g000 *= norm0.x;
				  g010 *= norm0.y;
				  g100 *= norm0.z;
				  g110 *= norm0.w;
				  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
				  g001 *= norm1.x;
				  g011 *= norm1.y;
				  g101 *= norm1.z;
				  g111 *= norm1.w;

				  float n000 = dot(g000, Pf0);
				  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
				  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
				  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
				  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
				  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
				  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
				  float n111 = dot(g111, Pf1);

				  vec3 fade_xyz = fade(Pf0);
				  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
				  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
				  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
				  return 2.2 * n_xyz;
				}
			// -------------------------------------------------------------->

			varying float noise;
			varying float noise2; 
			uniform float time;

			// Gui parameters
			uniform float displacementSize;
			uniform float noise_size;

			float turbulence( vec3 p ) {
			  float t = -.35;
			  for (float f = 1.0 ; f <= 10.0 ; f++ ){
			    float power = pow( 2.0, f );
			    t += abs( pnoise( vec3( power * p ), vec3( 10.0, 10.0, 10.0 ) ) / power );
			  }
			  return t;
			}

			void main() {

			  noise = 18.0 *  noise_size * turbulence( normal + time );
			  noise2 = 10.0 *  noise_size * turbulence( normal + time );
			  float b = 5.0 * pnoise( 0.05 * position + vec3( 2.0 * time ), vec3( 100.0 ) );
			  float displacement = - 5. * noise + b;

			  vec3 newPosition = position + normal * ( displacement * displacementSize);
			  gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
			}
		</script>

		<!-------- FRAGMENT SHADER - FOR EDITABLE SUN -------->
		<script type="x-shader/x-fragment" id="fragmentShader">

	      varying float noise;
	      varying float noise2;

	      // Gui parameters
	      uniform vec3 highlight;
	      uniform vec3 highlightBlend;
	      uniform vec3 blend; 
	      uniform vec3 innerGlow; 

	      void main() 
	      {
	      	vec3 colormix1 = mix(highlight, highlightBlend, (1. - 2. * noise2));
	      	vec3 colormix2 = mix(blend, innerGlow, (1. - 2. * noise));
	      	vec3 colorNoise = mix(colormix1, colormix2, (1. -2. * noise)); 
	      	gl_FragColor = vec4( colorNoise, 1.0);
	      }
		</script>

		<!--------- VERTEX SHADER - FOR SUN'S GLOW ----------->
		<script type="x-shader/x-vertex" id="glowVS">

			// ---------------------------- NOISE --------------------------->
				//
				// GLSL textureless classic 3D noise "cnoise",
				// with an RSL-style periodic variant "pnoise".
				// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
				// Version: 2011-10-11
				//
				// Many thanks to Ian McEwan of Ashima Arts for the
				// ideas for permutation and gradient selection.
				//
				// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
				// Distributed under the MIT license. See LICENSE file.
				// https://github.com/stegu/webgl-noise
				//

				vec3 mod289(vec3 x)
				{
				  return x - floor(x * (1.0 / 289.0)) * 289.0;
				}

				vec4 mod289(vec4 x)
				{
				  return x - floor(x * (1.0 / 289.0)) * 289.0;
				}

				vec4 permute(vec4 x)
				{
				  return mod289(((x*34.0)+1.0)*x);
				}

				vec4 taylorInvSqrt(vec4 r)
				{
				  return 1.79284291400159 - 0.85373472095314 * r;
				}

				vec3 fade(vec3 t) {
				  return t*t*t*(t*(t*6.0-15.0)+10.0);
				}

				// Classic Perlin noise
				float cnoise(vec3 P)
				{
				  vec3 Pi0 = floor(P); // Integer part for indexing
				  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
				  Pi0 = mod289(Pi0);
				  Pi1 = mod289(Pi1);
				  vec3 Pf0 = fract(P); // Fractional part for interpolation
				  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
				  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
				  vec4 iy = vec4(Pi0.yy, Pi1.yy);
				  vec4 iz0 = Pi0.zzzz;
				  vec4 iz1 = Pi1.zzzz;

				  vec4 ixy = permute(permute(ix) + iy);
				  vec4 ixy0 = permute(ixy + iz0);
				  vec4 ixy1 = permute(ixy + iz1);

				  vec4 gx0 = ixy0 * (1.0 / 7.0);
				  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
				  gx0 = fract(gx0);
				  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
				  vec4 sz0 = step(gz0, vec4(0.0));
				  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
				  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

				  vec4 gx1 = ixy1 * (1.0 / 7.0);
				  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
				  gx1 = fract(gx1);
				  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
				  vec4 sz1 = step(gz1, vec4(0.0));
				  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
				  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

				  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
				  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
				  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
				  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
				  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
				  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
				  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
				  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

				  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
				  g000 *= norm0.x;
				  g010 *= norm0.y;
				  g100 *= norm0.z;
				  g110 *= norm0.w;
				  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
				  g001 *= norm1.x;
				  g011 *= norm1.y;
				  g101 *= norm1.z;
				  g111 *= norm1.w;

				  float n000 = dot(g000, Pf0);
				  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
				  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
				  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
				  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
				  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
				  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
				  float n111 = dot(g111, Pf1);

				  vec3 fade_xyz = fade(Pf0);
				  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
				  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
				  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
				  return 2.2 * n_xyz;
				}

				// Classic Perlin noise, periodic variant
				float pnoise(vec3 P, vec3 rep)
				{
				  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
				  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
				  Pi0 = mod289(Pi0);
				  Pi1 = mod289(Pi1);
				  vec3 Pf0 = fract(P); // Fractional part for interpolation
				  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
				  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
				  vec4 iy = vec4(Pi0.yy, Pi1.yy);
				  vec4 iz0 = Pi0.zzzz;
				  vec4 iz1 = Pi1.zzzz;

				  vec4 ixy = permute(permute(ix) + iy);
				  vec4 ixy0 = permute(ixy + iz0);
				  vec4 ixy1 = permute(ixy + iz1);

				  vec4 gx0 = ixy0 * (1.0 / 7.0);
				  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
				  gx0 = fract(gx0);
				  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
				  vec4 sz0 = step(gz0, vec4(0.0));
				  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
				  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

				  vec4 gx1 = ixy1 * (1.0 / 7.0);
				  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
				  gx1 = fract(gx1);
				  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
				  vec4 sz1 = step(gz1, vec4(0.0));
				  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
				  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

				  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
				  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
				  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
				  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
				  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
				  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
				  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
				  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

				  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
				  g000 *= norm0.x;
				  g010 *= norm0.y;
				  g100 *= norm0.z;
				  g110 *= norm0.w;
				  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
				  g001 *= norm1.x;
				  g011 *= norm1.y;
				  g101 *= norm1.z;
				  g111 *= norm1.w;

				  float n000 = dot(g000, Pf0);
				  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
				  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
				  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
				  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
				  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
				  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
				  float n111 = dot(g111, Pf1);

				  vec3 fade_xyz = fade(Pf0);
				  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
				  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
				  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
				  return 2.2 * n_xyz;
				}
			// -------------------------------------------------------------->

			varying float noise;
			uniform float time;
			varying float intensity;
			uniform vec3 viewVector;

			// Gui parameters
			uniform float displacementSize;
			uniform float noise_size;
			uniform float c;
			uniform float p;

			float turbulence( vec3 p ) {
			  float t = -.35;
			  for (float f = 1.0 ; f <= 10.0 ; f++ ){
			    float power = pow( 2.0, f );
			    t += abs( pnoise( vec3( power * p ), vec3( 10.0, 10.0, 10.0 ) ) / power );
			  }
			  return t;
			}

			void main() {

			  noise = 18.0 *  noise_size * turbulence( normal + time );
			  float b = 5.0 * pnoise( 0.05 * position + vec3( 2.0 * time ), vec3( 100.0 ) );
			  float displacement = - 5. * noise + b;

			  vec3 vNormal = normalize( normalMatrix * normal );
		      vec3 vNormel = normalize( normalMatrix * viewVector );
		      intensity = pow( c - dot(vNormal, vNormel), p );

			  vec3 newPosition = position + normal * ( displacement * displacementSize);
			  gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
			}
		</script>

		<!--------- FRAGMENT SHADER - FOR SUN'S GLOW --------->
		<script type="x-shader/x-fragment" id="glowFS">

			varying float noise;
			varying float intensity;

			// Gui parameters
			uniform vec3 glowColor;
			uniform float opacity;

			void main()
			{
				vec3 glow = glowColor * intensity;
		      	vec3 colorNoise = mix(glow, glow, (1. -2. * noise)); 
				gl_FragColor = vec4( colorNoise, opacity);
			}
		</script>

		<!------------------ MAIN SCRIPT --------------------->
		<script type="module" id="main">

			// Importing scripts to work not only locally but on github.io 
			import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.112.0/build/three.module.js";
		   	import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.112.0/examples/jsm/controls/OrbitControls.js";
		    import {color, controllers, dom, gui, GUI} from "./js/dat.gui.module.js";

			var container, renderer, scene,
				camera, mesh, fov = 45, 
				cameraPosX = 0,
				cameraPosY = 100,
				cameraPosZ = 100,
				width = window.innerWidth, 
				height = window.innerHeight, 
				ratio =  width / height,
				start = Date.now();

			window.addEventListener( 'load', init );

			function init() {
			// <!----------------------------------- SETTING UP SCENE -------------------------------------------->
				container = document.getElementById( 'container' );
				scene = new THREE.Scene();
				renderer = new THREE.WebGLRenderer( {antialias:true});
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( width, height);
				renderer.autoClear = false;

				// Setting up camera
				camera = new THREE.PerspectiveCamera( fov, ratio, 1, 1000 );
				camera.position.set( cameraPosX, cameraPosY, cameraPosZ );
				camera.target = new THREE.Vector3( 0, 0, 0 );
				scene.add( camera );
				var controls = new OrbitControls( camera, renderer.domElement ); // Give user control of camera
				controls.enableDamping = true;
				controls.dampingFactor = 1;
				controls.enableKeys = true;
				controls.keys = {
					LEFT: 37, //left arrow
					UP: 38, // up arrow
					RIGHT: 39, // right arrow
					BOTTOM: 40 // down arrow
				}

				container.appendChild( renderer.domElement );
			// <!------------------------------------------------------------------------------------------------->

			// <!----------------------------------- MAIN GUI EDITABLE PLANET ------------------------------------>
				// Sunlight - 360 light
				var lightColor = 0xffffff,
					lightIntensity = 1.0,
					lightDistance = 0.0, // Default - unlimited distance
					lightDecay = 2.0, 
					sunlight = new THREE.PointLight( lightColor, lightIntensity, lightDistance, lightDecay);
				sunlight.power = lightIntensity * 4 * Math.PI; 
				sunlight.position.set( 0, 0, 0 );
				scene.add( sunlight );

				// Colors of the sun
				var highlight = 0xcc9900, 
					highlightBlend = 0xe65c00,
					blend = 0xff0000,
					innerGlow = 0x000000;

				// Noise parameters
				var noiseSpeed = .000030,
					noiseSize = -0.10,
					noiseDisplacement = -0.30;

				// Adding the sun to the scene
				var sunSize = 20,
					sunGeometry = new THREE.IcosahedronGeometry( sunSize, 6 ),
					sunMaterial = new THREE.ShaderMaterial({
									uniforms: {
										highlight: {value: new THREE.Color(highlight)},
										highlightBlend: {value: new THREE.Color(highlightBlend)},
										blend: {value: new THREE.Color(blend)},
										innerGlow: {value: new THREE.Color(innerGlow)},
										displacementSize: {value: noiseDisplacement},
										noise_size: {value: noiseSize},
										time: {value: 0}
									},
									vertexShader: document.getElementById('vertexShader').textContent,
									fragmentShader: document.getElementById('fragmentShader').textContent,
									side: THREE.DoubleSide
									});
				var sun = new THREE.Mesh( sunGeometry, sunMaterial );
				sun.overdraw = true;
				scene.add( sun );

				// Glow parameters
				var glowSize = sunSize + 5,
					glowColor = 0xe65c00,
					glowStrength = 0.2,
					glowSharpness = 1.9,
					glowOpacity = 1.0;

				// Adding Glow around the sun 
				var glowGeometry = new THREE.IcosahedronGeometry( glowSize, 4 ),
					glowMaterial = new THREE.ShaderMaterial({
									uniforms: {
										"c":   { type: "f", value: glowStrength },
										"p":   { type: "f", value: glowSharpness },
										opacity: { value: glowOpacity},
										glowColor: { value: new THREE.Color(glowColor) },
										viewVector: { type: "v3", value: camera.position },
										displacementSize: {value: noiseDisplacement},
										noise_size: {value: noiseSize},
										time: {value: 0}
									},
									vertexShader: document.getElementById('glowVS').textContent,
									fragmentShader: document.getElementById('glowFS').textContent,
									side: THREE.BackSide,
									blending: THREE.AdditiveBlending,
									transparent: true
									});
				var glow = new THREE.Mesh( glowGeometry, glowMaterial ) ;
				scene.add(glow);
			// <!------------------------------------------------------------------------------------------------->

			// <!----------------------------------- ADDING PLANETS TO SOLAR SYSTEM ------------------------------>
				// Function that generates planets with images as textures
				function generatePlanet(radius, text, radX, radY, radZ, rotSpeed, orbitSpeed)
				{
					var geometry = new THREE.SphereGeometry( radius, 32, 32 ),
						texture = new THREE.TextureLoader().load( text );
					
					//Wrap texture
					texture.wrapS = texture.wrapT = THREE.MirroredRepeatWrapping;
					texture.repeat.set( 1, 1 );
					
					var material = new THREE.MeshPhongMaterial({
							map : texture,
							side : THREE.DoubleSide
						}),
						planet = new THREE.Mesh( geometry, material );
					
					// Orbit radius and rotations
					planet.orbitRadiusX = radX;
					planet.orbitRadiusY = radY;
					planet.orbitRadiusZ = radZ;
					planet.rotSpeed = rotSpeed; 
					planet.rot = 2;
					planet.orbitSpeed = orbitSpeed;
					planet.orbit = Math.PI * 2;
					planet.position.set(radX, radY, radZ);

					scene.add(planet);
					return planet;
				}

				// Function that generates planets rings with images as textures
				function generatePlanetRing(planet, inR, outR, thetaSeg, phiSeg,thetaStart, thetaLength, text, posX, posY, posZ)
				{
					var ringgeometry = new THREE.RingGeometry(inR, outR, thetaSeg, phiSeg, thetaStart, thetaLength),
						texture = new THREE.TextureLoader().load( text );

					const uniforms = THREE.UniformsUtils.merge([
					    THREE.UniformsLib.ambient,
					    THREE.UniformsLib.lights,
					    THREE.UniformsLib.shadowmap,
					    {
					      ringTexture: { value: null },
					      innerRadius: { value: 0 },
					      outerRadius: { value: 0 },
					      lightPosition: { value: null }
					    }
					  ]);
					uniforms.ringTexture.value = texture;
					uniforms.innerRadius.value = inR;
					uniforms.outerRadius.value = outR;
					uniforms.lightPosition.value = new THREE.Vector3(-5, 5, 1);

					const ringmaterial = new THREE.ShaderMaterial({
					    uniforms,
					    vertexShader: `
							varying vec3 vPos;                                                     
							varying vec3 vWorldPosition;                                           
							varying vec3 vNormal;                                                 

							${THREE.ShaderChunk["shadowmap_pars_vertex"]}                         

							void main() {                                                         
							  vPos = position;                                                     
							  //vec4 worldPosition = (modelViewMatrix * vec4(position, 1.));         
							  vec4 worldPosition = modelMatrix * vec4(position, 1.0);

							  gl_Position = projectionMatrix * viewMatrix * vec4(worldPosition.xyz, 1.);       

							  vNormal = normalMatrix * normal;                                     
							  vWorldPosition = worldPosition.xyz;                                 

							  ${THREE.ShaderChunk["shadowmap_vertex"]}
							}`,
					    fragmentShader: `
							uniform sampler2D ringTexture;
							uniform float innerRadius;
							uniform float outerRadius;
							uniform vec3 lightPosition;
							varying vec3 vPos;

							${THREE.ShaderChunk["common"]}
							${THREE.ShaderChunk["packing"]}
							${THREE.ShaderChunk["bsdfs"]}
							${THREE.ShaderChunk["lights_pars_begin"]}
							${THREE.ShaderChunk["shadowmap_pars_fragment"]}
							${THREE.ShaderChunk["shadowmask_pars_fragment"]}

							vec4 color() {
							  vec2 uv = vec2(0);
							  uv.x = (length(vPos) - innerRadius) / (outerRadius - innerRadius);
							  if (uv.x < 0.0 || uv.x > 1.0) {
							    discard;
							  }                                                                           
							  vec4 pixel = texture2D(ringTexture, uv);
							  return pixel;
							}

							void main() {
							  gl_FragColor = color() * vec4(vec3(getShadowMask()), 1.0);
							}`,
					    transparent: true,
					    lights: true,
					    side: THREE.DoubleSide,
					});
						
					var	ring = new THREE.Mesh( ringgeometry, ringmaterial );
					ring.castShadow = true;
	  				ring.receiveShadow = false;
					ring.rotation.x = THREE.Math.degToRad(90);

					planet.add(ring);
					return ring; 
				}

				// Function that generates planets orbit path around the sun
				function generateOrbitLine(orbitRadX, orbitRadY)
				{
					var curve = new THREE.EllipseCurve(
									0,  0,            		// ax, aY
									orbitRadX, orbitRadY,	// xRadius, yRadius
									0,  2 * Math.PI,  		// aStartAngle, aEndAngle
									false,            		// aClockwise
									0                		// aRotation
								),
						points = curve.getPoints( 150 ),
						geometry = new THREE.BufferGeometry().setFromPoints( points ),
						material = new THREE.MeshBasicMaterial({
									  color: 0xffffff,
									  transparent: true,
									  opacity: 0.2,
									  side: THREE.DoubleSide
									}),
						ellipse = new THREE.Line( geometry, material );
					
					ellipse.rotation.x = THREE.Math.degToRad(90);

					scene.add(ellipse);
					return ellipse; 
				}

				// Positions, Rotation Speed, Orbit Speed 
				// Sources: http://www.qrg.northwestern.edu/projects/vss/docs/space-environment/3-orbital-lengths-distances.html
				//			https://www.universetoday.com/15462/how-far-are-the-planets-from-the-sun/
				//			https://www.space.com/18145-how-far-is-the-moon.html
				// 			https://nssdc.gsfc.nasa.gov/planetary/factsheet/
				//			https://spaceplace.nasa.gov/days/en/
				// 			https://www.space.com/24871-does-the-moon-rotate.html
				var earthRadX = 91, earthRadY = 94, earthRadZ = 0,						// 91-94 million miles from the sun
						earRS = 0.001,													// We set 0.001 as 1 Earth day
						earOS = 0.0025,													// We set 0.005 as 1 Earth year

					mercuryRadX = 43, mercuryRadY = 29, mercuryRadZ = 0,				// 29-43 million miles from the sun
						merRS = earRS * (24/1408),										// 1,408 Earth hours
						merOS = earOS * (12/3),											// 3 Earth months

					venusRadX = 68, venusRadY = 66, venusRadZ = 0,						// 66-68 million miles from the sun
						venRS = earRS * (24/5832), 									// 5,832 Earth hours
						venOS = earOS * (12/7), 										// 7 Earth months

					moonRadX = 0.252088, moonRadY = 0.225623, moonRadZ = 0, 			// 225,623-252,088  miles from earth
						monRS = earRS / 27.322, 										// Orbits Earth once every 27.322 days
						monOS = earRS * 27,												// 27 Earth days

					marsRadX = 155, marsRadY = 127, marsRadZ = 0, 						// 127-155 million miles from the sun
						marRS = earRS * (24/25), 										// 25 Earth hours
						marOS = earOS * (12/23),										// 23 Earth months

					jupiterRadX = 508, jupiterRadY = 460, jupiterRadZ = 0,				// 460-508 million miles from the sun
						jupRS = earRS * (24/10), 										// 10 Earth hours
						jupOS = earOS * (12/142),										// 142 Earth months	

					saturnRadX = 938, saturnRadY = 839, saturnRadZ = 0, 				// 839-938 million miles from the sun
						satRS = earRS * (24/11), 										// 11 Earth hours
						satOS = earOS / 29.5,											// 29.5 Earth years

					uranusRadX = 1860, uranusRadY = 1710, uranusRadZ = 0, 				// 1710-1860 million miles from the sun
						uraRS = earRS * (24/17), 										// 17 Earth hours
						uraOS = earOS / 84.0,											// 84 Earth years

					neptuneRadX = 2830, neptuneRadY = 2770, neptuneRadZ = 0, 			// 2770-2830 million miles from the sun
						nepRS = earRS * (24/16), 										// 16 Earth hours
						nepOS = earOS * (12/1979);										// 1979 Earth months

				// Size of the planets
				// Sources: http://coolcosmos.ipac.caltech.edu/ask/167-How-small-is-the-Moon-compared-to-Earth-
				//			http://coolcosmos.ipac.caltech.edu/ask/5-How-large-is-the-Sun-compared-to-Earth-
				//			https://www.universetoday.com/36649/planets-in-order-of-size/
				var earSize = sunSize / 109,			// (6,371 km / 3,959 miles) 	- Earth is 109 times smaller than the sun
					merSize = earSize * 0.38, 			// (2,440 km / 1,516 miles)		– 38% the size of Earth
					venSize = earSize * 0.95, 			// (6,052 km / 3,761 miles) 	– 95% the size of Earth
					monSize = earSize * 0.25,			// (3,476 km / 2,159 miles) 	- 25% the size of Earth
					marSize = earSize * 0.53, 			// (3,390 km / 2,460 miles) 	– 53% the size of Earth
					jupSize = earSize * 11.2, 			// (69,911 km / 43,441 miles) 	– 1120% the size of Earth
					satSize = earSize * 9.45, 			// (58,232 km / 36,184 miles) 	– 945% the size of Earth
					uraSize = earSize * 4.0, 			// (25,362 km / 15,759 miles) 	– 400% the size of Earth
					nepSize = earSize * 3.88; 			// (24,622 km / 15,299 miles) 	– 388% the size of Earth

				// Adding the Earth + Clouds + Moon
				var geometryEarth = new THREE.SphereGeometry(earSize, 32, 32),
					geometryClouds = new THREE.SphereGeometry(earSize+0.005, 32, 32),
					geometryMoon = new THREE.SphereGeometry(monSize, 32, 32),
					materialEarth = new THREE.MeshPhongMaterial({
						map 		: new THREE.TextureLoader().load('img/textures/earth.jpg'),
						bumpMap 	: new THREE.TextureLoader().load('img/textures/earthbump.jpg'),
						bumpScale 	: 0.05,
						side 		: THREE.DoubleSide,
						//specularMap : new THREE.TextureLoader().load('img/textures/earthspec.jpg'),
						//specular 	: new THREE.Color('grey'),
					}),
					materialClouds  = new THREE.MeshStandardMaterial({
						map     	: new THREE.TextureLoader().load('img/textures/earthcloud.jpg'),
						side        : THREE.DoubleSide,
						opacity     : 0.6,
						transparent : true,
						depthWrite  : false
					}),
					materialMoon  = new THREE.MeshPhongMaterial({
						map     	: new THREE.TextureLoader().load('img/textures/moon.jpg'),
						side        : THREE.DoubleSide,
					}),
					earth = new THREE.Mesh(geometryEarth, materialEarth),
					clouds = new THREE.Mesh(geometryClouds, materialClouds),
					moon = new THREE.Mesh(geometryMoon, materialMoon);
					earth.receiveShadow = true;
					clouds.receiveShadow = true;
					moon.castShadow = true;

				// Orbit radius and rotations
				earth.orbitRadiusX = earthRadX;
				earth.orbitRadiusY = earthRadY;
				earth.orbitRadiusZ = earthRadZ;
				earth.rotSpeed = earRS;
				earth.rot = 2;
				earth.orbitSpeed = earOS;
				earth.orbit = Math.PI * 2;
				earth.position.set(earthRadX, earthRadY, earthRadZ);

				moon.orbitRadiusX = moonRadX;
				moon.orbitRadiusY = moonRadY;
				moon.orbitRadiusZ = moonRadZ;
				moon.rotSpeed = monRS;
				moon.rot = 2;
				moon.orbitSpeed = monOS;
				moon.orbit = Math.PI * 2;
				moon.position.set(moonRadX, moonRadY, moonRadZ);

				scene.add( earth );
				earth.add( clouds );
				earth.add( moon );

				// Adding planets (with image textures) to scene
				var mercury = generatePlanet(merSize, "img/textures/mercury.jpg" , mercuryRadX, mercuryRadY, mercuryRadZ, merRS, merOS),
					venus = generatePlanet(venSize, "img/textures/venus.jpg", venusRadX, venusRadY, venusRadZ, venRS, venOS),
					mars = generatePlanet(marSize, "img/textures/mars.jpg", marsRadX, marsRadY, marsRadZ, marRS, marOS),
					jupiter = generatePlanet(jupSize, "img/textures/jupiter.jpg", jupiterRadX, jupiterRadY, jupiterRadZ, jupRS, jupOS),
					saturn = generatePlanet(satSize, "img/textures/saturn.jpg", saturnRadX, saturnRadY, saturnRadZ, satRS, satOS),
					saturnRing = generatePlanetRing(saturn, 2.0, 3.6, 30, 30, 0, 6.3, "img/textures/saturn_ring.png", saturnRadX, saturnRadY, saturnRadZ),
					uranus = generatePlanet(uraSize, "img/textures/uranus.jpg", uranusRadX, uranusRadY, uranusRadZ, uraRS, uraOS),
					uranusRing = generatePlanetRing(uranus, 1.0, 1.8, 30, 30, 0, 6.3, "img/textures/uranus_ring.jpg", uranusRadX, uranusRadY, uranusRadZ),
					neptune = generatePlanet(nepSize, "img/textures/neptune.jpg", neptuneRadX, neptuneRadY, neptuneRadZ, nepRS, nepOS);

				// Adding planets orbits around the sun
				generateOrbitLine(mercuryRadX, mercuryRadY),
				generateOrbitLine(venusRadX, venusRadY), 
				generateOrbitLine(earthRadX, earthRadX),
				generateOrbitLine(marsRadX, marsRadY),
				generateOrbitLine(jupiterRadX, jupiterRadY),
				generateOrbitLine(saturnRadX, saturnRadY),
				generateOrbitLine(uranusRadX, uranusRadY),
				generateOrbitLine(neptuneRadX, neptuneRadY);
			// <!------------------------------------------------------------------------------------------------->

			// <!----------------------------------- ADDING A STARRY BACKGROUND ---------------------------------->
				// Create particles
				var particleCount = 2000,
				    particles = new THREE.Geometry(),
				    ptexture = new THREE.TextureLoader().load("img/textures/star.png"),
				    pMaterial = new THREE.PointsMaterial({
				      color: 0xFFFFFF,
				      map: ptexture,
				      transparent: true, 
				      blending: THREE.AdditiveBlending,
				      depthTest: true, 
				      size: 2
				});

				// Create the individual particles
				for (var p = 0; p < particleCount; p++) {
				  // Create a particle with random x position
				  var pX = Math.random() * 840 - 320,
				      pY = Math.random() * 840 - 320,
				      pZ = Math.random() * 840 - 320,
				      particle = new THREE.Vector3(pX, pY, pZ);
				  particles.vertices.push(particle);
				}

				// Create the particle system
				var particleSystem = new THREE.Points(particles, pMaterial);
				particleSystem.sortParticles = true;
				scene.add(particleSystem);
			// <!------------------------------------------------------------------------------------------------->

			// <!----------------------------------- CREATING GUI ------------------------------------------------>
				var controller = new function() {
				  this.positionX = cameraPosX;
				  this.positionY = cameraPosY;
				  this.positionZ = cameraPosZ;
				  // Camera goes to planets position
					  this.Mercury = function () {
					  	camera.position.x = mercury.position.x;
					    camera.position.y = mercury.position.y;
					    camera.position.z = mercury.position.z; 
					    controls.update();
					  };
					  this.Venus = function () {
					  	camera.position.x = venus.position.x;
					    camera.position.y = venus.position.y;
					    camera.position.z = venus.position.z; 
					    controls.update();
					  };
					  this.Earth = function () {
					  	camera.position.x = earth.position.x;
					    camera.position.y = earth.position.y;
					    camera.position.z = earth.position.z;
					    controls.update(); 
					  };
					  this.Mars = function () {
					  	camera.position.x = mars.position.x;
					    camera.position.y = mars.position.y;
					    camera.position.z = mars.position.z; 
					    controls.update();
					  };
					  this.Jupiter = function () {
					  	camera.position.x = jupiter.position.x;
					    camera.position.y = jupiter.position.y;
					    camera.position.z = jupiter.position.z; 
					    controls.update();
					  };
					  this.Saturn = function () {
					  	camera.position.x = saturn.position.x;
					    camera.position.y = saturn.position.y;
					    camera.position.z = saturn.position.z; 
					    controls.update();
					  };
					  this.Uranus = function () {
					  	camera.position.x = uranus.position.x;
					    camera.position.y = uranus.position.y;
					    camera.position.z = uranus.position.z; 
					    controls.update();
					  };
					  this.Neptune = function () {
					  	camera.position.x = neptune.position.x;
					    camera.position.y = neptune.position.y;
					    camera.position.z = neptune.position.z; 
					    controls.update();
					  };
				  this.Highlight_Color = highlight;
				  this.Blend_Color = blend;
				  this.Inner_Glow = innerGlow;
				  this.Glow_Size = glowSize;
				  this.Glow_Color = glowColor;
				  this.Glow_Sharpness = glowSharpness;
				  this.Glow_Opacity = glowOpacity;
				  this.Noise_Speed = noiseSpeed; 
				  this.Noise_Size = noiseSize; 
				  this.Noise_Displacement = noiseDisplacement; 
				  this.Reset = function (){
					  	// Camera
					  	camera.position.set(cameraPosX,cameraPosY,cameraPosZ);
					  	controller.positionX = cameraPosX;
					  	controller.positionY = cameraPosY;
					  	controller.positionZ = cameraPosZ;
					  	controls.reset();
					    controls.update();

					    // Sun
					    highlight = 0xcc9900;
					    sunMaterial.uniforms.highlight = {value: new THREE.Color(highlight)};
					    controller.Highlight_Color = highlight;
						blend = 0xff0000;
						sunMaterial.uniforms.blend = {value: new THREE.Color(blend)};
						controller.Blend_Color = blend;
						innerGlow = 0x000000;
						sunMaterial.uniforms.innerGlow = {value: new THREE.Color(innerGlow)};
						controller.Inner_Glow = innerGlow;

						// Sun Glow
						glowSize = sunSize + 5;
						glow.scale.x = glowSize * 0.044;
						glow.scale.y = glowSize * 0.044;
						glow.scale.z = glowSize * 0.044;
						controller.Glow_Size = glowSize;
						glowColor = 0xe65c00;
						glowMaterial.uniforms.glowColor = { type: "c", value: new THREE.Color(glowColor) };
						controller.Glow_Color = glowColor;
						glowSharpness = 1.9;
						glowMaterial.uniforms.p = { type: "f", value: glowSharpness };
						controller.Glow_Sharpness = glowSharpness;
						glowOpacity = 1.0;
						glowMaterial.uniforms.opacity = { value: glowOpacity };
						controller.Glow_Opacity = glowOpacity;

						// Noise 
						noiseSpeed = .000030;
						controller.Noise_Speed = noiseSpeed;
						noiseSize = -0.10;
						sunMaterial.uniforms.noise_size = {value: noiseSize};
						glowMaterial.uniforms.noise_size = {value: noiseSize};
						controller.Noise_Size = noiseSize;
						noiseDisplacement = -0.30;
						sunMaterial.uniforms.displacementSize = {value: noiseDisplacement};
						glowMaterial.uniforms.displacementSize = {value: noiseDisplacement};
						controller.Noise_Displacement = noiseDisplacement;
					  };
					};

				var gui = new dat.GUI({name: 'Control the solar system'});
				
				// View all planets up close
				var cameraPos = gui.addFolder('Camera position');
					cameraPos.add(controller, 'positionX', -100, 100).onChange( function() {
					   camera.position.x = controller.positionX;
					   controls.update();
					}).listen().name('X');
					cameraPos.add(controller, 'positionY', -100, 100).onChange( function() {
					   camera.position.y = controller.positionY;
					   controls.update();
					}).listen().name('Y');
					cameraPos.add(controller, 'positionZ', -100, 100).onChange( function() {
					   camera.position.z = controller.positionZ;
					   controls.update();
					}).listen().name('Z');
					cameraPos.add( controller, 'Mercury').listen();
					cameraPos.add( controller, 'Venus').listen();
					cameraPos.add( controller, 'Earth').listen();
					cameraPos.add( controller, 'Mars').listen();
					cameraPos.add( controller, 'Jupiter').listen();
					cameraPos.add( controller, 'Saturn').listen();
					cameraPos.add( controller, 'Uranus').listen();
					cameraPos.add( controller, 'Neptune').listen();

				// Color folder
				var colorFolder = gui.addFolder('Colors of the sun');
					colorFolder.addColor(controller, 'Highlight_Color', highlight ).onChange( function() {
						highlight = controller.Highlight_Color;
						sunMaterial.uniforms.highlight = {value: new THREE.Color(highlight)};
					}).listen().name('Highlight Color');
					colorFolder.addColor(controller, 'Blend_Color', blend ).onChange( function() {
						blend = controller.Blend_Color;
						sunMaterial.uniforms.blend = {value: new THREE.Color(blend)};
					}).listen().name('Blending Color');
					colorFolder.addColor(controller, 'Inner_Glow', innerGlow ).onChange( function() {
						innerGlow = controller.Inner_Glow;
						sunMaterial.uniforms.innerGlow = {value: new THREE.Color(innerGlow)};
					}).listen().name('Inner Glow');

				// Glow folder
				var glowFolder = gui.addFolder('Sun glow');
					glowFolder.add( controller, 'Glow_Size', 20.0, 40.0 ).onChange( function() {
				  		glowSize = controller.Glow_Size;
				  		var scale = glowSize * 0.044;
						glow.scale.x = scale;
						glow.scale.y = scale;
						glow.scale.z = scale;
					} ).listen().name('Size');
					glowFolder.addColor(controller, 'Glow_Color', glowColor ).onChange( function() {
						glowColor = controller.Glow_Color;
						glowMaterial.uniforms.glowColor = {value: new THREE.Color(glowColor)};
					}).listen().name('Color');
					glowFolder.add(controller, 'Glow_Sharpness', 0.0, 6.0 ).onChange( function() {
						glowSharpness = controller.Glow_Sharpness;
						glowMaterial.uniforms.p = { type: "f", value: glowSharpness };
					}).listen().name('Sharpness');
					glowFolder.add( controller, 'Glow_Opacity', 0.0, 1.0 ).onChange( function() {
				  		glowOpacity = controller.Glow_Opacity;
				  		glowMaterial.uniforms.opacity = { value: glowOpacity };
					} ).listen().name('Opacity');

				// Noise folder 
				var noiseFolder = gui.addFolder('Sun noise');
					noiseFolder.add( controller, 'Noise_Speed', 0.0, 0.001).onChange( function() {
						noiseSpeed = controller.Noise_Speed;
					}).listen().name('Speed');
					noiseFolder.add( controller, 'Noise_Size', -1.0, -0.0).onChange( function() {
						noiseSize = controller.Noise_Size;
						sunMaterial.uniforms.noise_size = {value: noiseSize};
						glowMaterial.uniforms.noise_size = {value: noiseSize};
					}).listen().name('Size');
					noiseFolder.add( controller, 'Noise_Displacement', -2.0, -0.0).onChange( function() {
						noiseDisplacement = controller.Noise_Displacement;
						sunMaterial.uniforms.displacementSize = {value: noiseDisplacement};
						glowMaterial.uniforms.displacementSize = {value: noiseDisplacement};
					}).listen().name('Displacement');

				// Reset button
				gui.add( controller, 'Reset').name('Reset settings');
			// <!------------------------------------------------------------------------------------------------->

			// <!----------------------------------- RENDERING SETTINGS ------------------------------------------>
				function onWindowResize() {
					renderer.setSize( width, height );
					camera.aspect = ratio;
					camera.updateProjectionMatrix();
				}
				
				// Updating the planets orbits around the sun
				function planetUpdate(planet)
				{
					// Planets rotations
					planet.rot += planet.rotSpeed;
				    planet.rotation.set(0, planet.rot, 0);

				    // Planets orbit 
				    planet.orbit += planet.orbitSpeed;
				    planet.position.set(Math.cos(planet.orbit) * planet.orbitRadiusX, 0, Math.sin(planet.orbit) * planet.orbitRadiusY);
				}

				// Updating the cameras position to follow a planet - smaller planets
				function cameraUpdateA(camera, planet)
				{
					//camera.lookAt(planet.position);

					// Planets rotations
					planet.rot += planet.rotSpeed;
				    camera.rotation.set(0, planet.rot, 0);

				    // Planets orbit 
				    planet.orbit += planet.orbitSpeed;
				    camera.position.set(Math.cos(planet.orbit) * (planet.orbitRadiusX+2), 0.2, Math.sin(planet.orbit) * (planet.orbitRadiusY+2));
				}

				// Updating the cameras position to follow a planet - bigger planets
				function cameraUpdateB(camera, planet)
				{
					//camera.lookAt(planet.position);

					// Planets rotations
					planet.rot += planet.rotSpeed;
				    camera.rotation.set(0, planet.rot, 0);

				    // Planets orbit 
				    planet.orbit += planet.orbitSpeed;
				    camera.position.set(Math.cos(planet.orbit) * (planet.orbitRadiusX+10), 1, Math.sin(planet.orbit) * (planet.orbitRadiusY+10));
				}

				var viewLight = new THREE.AmbientLight( 0xFFFFFF ); // white
				//scene.add( viewlight );

				function render() {
					
					planetUpdate(mercury);
					planetUpdate(venus);
					planetUpdate(earth);
					planetUpdate(moon);
					planetUpdate(mars);
					planetUpdate(jupiter);
					planetUpdate(saturn);
					planetUpdate(uranus);
					planetUpdate(neptune);

					// Rotations
					particleSystem.rotation.y -= 0.0001;
					sun.rotation.y -= 0.0001;
					clouds.rotation.y  += 0.0001;

					// Adding noise movement
					sunMaterial.uniforms[ 'time' ].value = noiseSpeed * ( Date.now() - start );
					glowMaterial.uniforms[ 'time' ].value = noiseSpeed * ( Date.now() - start )

					//Update the camera position
					//camera.position.x += 0.01;
					//camera.position.y -= 0.01;
					//camera.position.z -= 0.05;

					//Flyby reset
					//if (camera.position.z < -100) {
					//camera.position.set(0,35,70);
					//}

					//Point the camera towards the earth
					//if( camera.position.x = earth.position.x)
					//{
						//camera.lookAt(mercury.position);
						//cameraUpdateA(camera, mercury);
					//}
					
					controls.update();
					requestAnimationFrame( render );
					renderer.render( scene, camera );
				}

				window.addEventListener( 'resize', onWindowResize, false );

				render();
			// <!------------------------------------------------------------------------------------------------->
			}
		</script>
	</body>
</html>